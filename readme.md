迁移过去的模型是要对来自源域的设备进行快速认证，而不是要对目标域设备进行识别（虽然迁移学习的大多为此应用）

由于不同域**环境差异**，将会对设备信号产生影响，影响源模型在目标域对源域设备的认证效果；因此需要对**迁移的模型进行微调**，学习适应目标域的环境特性，使得源域模型在目标域仍能保持良好的准确度。

# 一．QA
**1.来自其他n个域的设备向同一个目标域进行跨域认证，需要迁移n个模型？**

目标域根据设备的来源选择对应的模型对其进行认证

**2.目标域与本域的分类模型架构：**

基于XGBoost训练分类器

**3.射频指纹的表示形式：**

信号IQ向量的实部（I 分量）和虚部（Q 分量）

**4.分类结果**

设备标签

# 二．实现流程
## 1.信号采集：
采集设备信号，标注标签

## 2.信号预处理：
对原始信号进行去噪和信道均衡，去除噪声和信道对射频指纹识别的干扰

## 3.特征提取
IQ向量的实部（I 分量）和虚部（Q 分量）

## 4.分类识别
**基于****XGBoost****实现分类任务：**

XGBoost 使用梯度提升算法来训练一组决策树。每一棵新树都试图纠正前一棵树的错误。每一棵树的训练是基于前一棵树的**残差**（预测误差）。即，每棵树在前一棵树的基础上调整预测值，逐步改进预测性能。

**原理****：**

**初始化模型**：开始时，所有样本的预测值是一个常数（通常是样本标签的平均值）。

**计算残差**：通过计算当前预测与真实标签之间的差异（即残差）来确定模型的错误部分。

**训练新树**：基于当前的残差训练新的树，每一棵树都试图最小化残差。每棵树的目标是对前一棵树的错误进行修正。

**更新模型**：将每棵新树的输出加权，并更新模型的整体预测值。

**重复迭代**：重复训练多棵树，直到达到设定的树数量或性能指标为止。

**最终预测**：在多分类问题中，XGBoost 的每棵树都会输出一个**得分向量**，该向量表示样本在每个类别上的“信心”。所有树的得分会加起来，通常通过学习率加权控制每棵树的影响。

最终的得分向量会通过**Softmax 函数** 转换为概率分布，表示样本属于每个类别的概率。

![](https://cdn.nlark.com/yuque/0/2024/png/49662704/1734094830984-8a193ecd-07d1-4a75-8c9c-7aa229ffc188.png)

模型最终选择概率最大的类别作为预测结果。

## 5. 迁移方案
迁移学习的两种主要方法分别是**微调**方法和**冻结层**方法

微调方法中，需要对**整个网络参数进行再训练**

冻结层方法**冻结了大部分传递的参数**，只对部分参数进行调整

### 5.1跨域认证挑战
不同域（不同的环境、频率范围、噪声水平或信道条件）可能会导致设备射频指纹的分布发生变化。设备的射频指纹包含部分与域环境相关的特征。

将本地模型迁移到目标域后，为了使模型能够更好地适应目标域的特定特性和分布，一般使用目标域的数据进行训练，对模型进行微调。

### 5.2XGBoost迁移
XGBoost 是一种基于决策树的梯度提升树（GBDT）方法，其模型是由一系列决策树组成的。每棵树的生成过程相对独立，且树与树之间**没有像神经网络中那样的共享权重**。树的构建是基于特征的划分和节点的分裂，因此每棵树的学习过程并不涉及对权重的学习，而是通过增量学习在每一轮迭代中构建新的树来逐步优化模型的预测结果。

因此XGBoost并没有直接的权重结构可以迁移，不能通过冻结部分模型层（比如低层特征提取部分），只微调高层网络的方式实现迁移。

### 5.3迁移策略
在保持源域模型的结构和参数的基础上，微调部分模型。保留源域模型的决策树（通过 Booster），并在目标域数据上继续训练（通过增量训练）。因此，不会重新训练所有的参数，只会对模型进行适应性调整，以便更好地处理目标域数据。

将源域模型作为初始模型，然后使用目标域数据对该模型进行微调：

**1.target_model._Booster = source_model._Booster**

将source_model的核心部分（即 Booster 对象）复制到 target_model，从而实现模型状态的共享或迁移，相当于让 target_model 拥有 source_model 的所有训练成果。

**Booster ****是模型的核心**，它包含了训练后的所有决策树和相关参数。_Booster 是 XGBoost 模型的内部属性，保存了模型的具体结构和状态，包括模型参数和树的结构。

**2.target_model.fit(X_train_target, ****Y****_train_target, xgb_model=model_Source.get_booster())**

xgb_model=model_Source.get_booster() 在 fit 中指定了微调起点，表示目标模型将从源域模型的树结构开始继续训练。

### 5.4整体流程
1.在源域内训练一个认证模型

2.当设备需要跨域认证时，将源域模型传送到目标域。（测试对来自源域的设备信号识别准确率）

3.目标域以该模型为起点，使用目标域内数据进行训练，对模型微调

target_model._Booster = model_Source._Booster  
target_model.fit(X_subset,Y_subset, xgb_model=model_Source.get_booster())

4.目标域使用调整后的迁移模型对设备进行认证，测试分类准确率。

### 5.5目前工作——基于XGboost分类器
**WiSi**g数据集： **解决了射频指纹生成问题，可以直接使用**

每个信号数据样本存储为 IQ 样本（复数形式的幅度和相位数据），并附带以下标签信息：

发射器编号 (Tx ID)：来自哪个发射器；

接收器编号 (Rx ID)：由哪个接收器捕获；

日期 (Day)：捕获的具体日期；

![](https://cdn.nlark.com/yuque/0/2024/png/49662704/1734094831089-478f9a66-5a7c-472b-bf50-eec052698d0d.png)

#### 1）信号数据集提取（使用SingleDay数据集）
**Rx_a**为域A基站的接收机

**Rx_b**为域B基站的接收机

**Tx_a1,Tx_a2,...,Tx_an**为域A的设备

**Tx_b1,Tx_b2,...,Tx_bm**为域B的设备

提取信号数据集：

C(Tx_ai，Rx_a)为域A本地设备信号

C(Tx_bi，Rx_b)为域B本地设备信号

C(Tx_ai，Rx_b)为域B收到的来自域A设备的信号

C(Tx_ai，Rx_a)，C(Tx_ai，Rx_b)体现跨域认证时的信号差异

![](https://cdn.nlark.com/yuque/0/2024/png/49662704/1734094851874-84ed1ba5-c9d8-4e0c-b2ef-00ea513161e6.png)

#### 2）本地模型训练
训练数据：**C(Tx_a1,Rx_a),C(Tx_a2,Rx_a),...,C(Tx_an,Rx_a)**

实现一个分类器对域A设备进行识别（目前**闭集任务**）

![](https://cdn.nlark.com/yuque/0/2024/png/49662704/1734095349002-46d8660a-4033-44a8-af5d-eb6ae628db1e.png)

基于XGBoost训练分类器，模型准确率：**0.974375**

![](https://cdn.nlark.com/yuque/0/2024/png/49662704/1734095392076-4f13ef50-987f-4df1-85a5-b2ffff6dc22e.png)

#### 3）迁移
源模型在域B的准确率：

![](https://cdn.nlark.com/yuque/0/2024/png/49662704/1734095425011-37ea45c8-c1d7-4404-951d-902a76adc86c.png)

接近于随机猜测。

![](https://cdn.nlark.com/yuque/0/2024/png/49662704/1734095468424-06157372-26d4-4cef-b084-a1503a5dbb68.png)

使用C(Tx_ai，Rx_b)中的少量数据（1/10）继续训练，决策树数目，树的最大深度都减少。

![](https://cdn.nlark.com/yuque/0/2024/png/49662704/1734095465589-a923fa35-732c-41f2-8d0b-01bcb7b2c148.png)

对信号C(Tx_a1，Rx_b),C(Tx_a2，Rx_b),...,C(Tx_an，Rx_b)进行识别，准确率：

## ![](https://cdn.nlark.com/yuque/0/2024/png/49662704/1734095499631-0d56c34c-0946-4d39-864a-86fef6466892.png)
